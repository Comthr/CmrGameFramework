using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Text;
using System.Reflection;

namespace CmrGame.Editor
{
    public static class ConfigCodeGenerator
    {
        public static void Generate(ConfigSOBase so)
        {
            Type soType = so.GetType();
            string soName = soType.Name;

            // 命名约定：LobbyConfigSO -> LobbyConfigAccessor
            // 如果你的 SO 不以 SO 结尾，这里可能需要调整 Replace 逻辑
            string accessorName = soName.EndsWith("SO") ? soName.Replace("SO", "Accessor") : soName + "Accessor";

            // 获取 SO 所在的命名空间
            string namespaceName = soType.Namespace;

            // 获取文件物理路径，确保 Accessor 生成在 SO 同级目录下
            MonoScript script = MonoScript.FromScriptableObject(so);
            string assetPath = AssetDatabase.GetAssetPath(script);
            string dirPath = Path.GetDirectoryName(assetPath);
            string outputPath = Path.Combine(dirPath, accessorName + ".cs");

            StringBuilder sb = new StringBuilder();

            // =========================================================
            // 代码构建
            // =========================================================

            sb.AppendLine("// ------------------------------------------------------------------------------");
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"//     Source: {soName}.cs");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("// ------------------------------------------------------------------------------");
            sb.AppendLine();

            // 引用基类 ConfigAccessor 所在的命名空间 (假设基类在 CmrGame)
            // 如果生成的类和基类在同一个命名空间，这个引用是多余的但无害
            sb.AppendLine("using CmrGame;");
            sb.AppendLine();

            // 包装命名空间 (完全跟随 SO 的命名空间)
            if (!string.IsNullOrEmpty(namespaceName))
            {
                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");
            }

            // 类定义
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// 自动生成的配置访问器，对应 {soName}");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public class {accessorName} : ConfigAccessor");
            sb.AppendLine("    {");

            // 1. 生成构造函数 (透传参数)
            sb.AppendLine($"        public {accessorName}(ConfigAgent agent, string groupName) : base(agent, groupName)");
            sb.AppendLine("        {");
            sb.AppendLine("        }");
            sb.AppendLine();

            // 2. 遍历字段生成属性
            // 只获取 Public 且是当前类声明的字段 (DeclaredOnly 避免把基类的 description 也生成进去)
            FieldInfo[] fields = soType.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

            foreach (var field in fields)
            {
                string typeName = GetTypeName(field.FieldType);
                string fieldName = field.Name;

                // 获取当前 SO 里的值作为默认值
                object defaultValue = field.GetValue(so);
                string defaultStr = FormatValue(defaultValue);

                // 映射方法: int -> GetInt
                string method = GetMethodName(field.FieldType);

                if (method != null)
                {
                    sb.AppendLine($"        public {typeName} {fieldName} => {method}(\"{fieldName}\", {defaultStr});");
                    sb.AppendLine();
                }
                else
                {
                    sb.AppendLine($"        // [Ignored] Unsupported type: {typeName} {fieldName}");
                }
            }

            sb.AppendLine("    }"); // End Class

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sb.AppendLine("}"); // End Namespace
            }

            // =========================================================
            // 写入
            // =========================================================

            try
            {
                File.WriteAllText(outputPath, sb.ToString(), Encoding.UTF8);
                AssetDatabase.Refresh();
                Debug.Log($"<color=green>[ConfigGenerator]</color> Success: {accessorName}.cs\nPath: {outputPath}");
            }
            catch (Exception e)
            {
                Debug.LogError($"[ConfigGenerator] Failed: {e.Message}");
            }
        }

        // --- 辅助方法 ---

        private static string GetTypeName(Type type)
        {
            if (type == typeof(int)) return "int";
            if (type == typeof(float)) return "float";
            if (type == typeof(string)) return "string";
            if (type == typeof(bool)) return "bool";
            return type.Name;
        }

        private static string GetMethodName(Type type)
        {
            if (type == typeof(int)) return "GetInt";
            if (type == typeof(float)) return "GetFloat";
            if (type == typeof(string)) return "GetString";
            if (type == typeof(bool)) return "GetBool";
            return null;
        }

        private static string FormatValue(object value)
        {
            if (value == null) return "null";
            if (value is bool b) return b.ToString().ToLower();
            if (value is string s) return $"\"{s}\"";
            if (value is float f) return $"{f}f";
            return value.ToString();
        }
    }
}